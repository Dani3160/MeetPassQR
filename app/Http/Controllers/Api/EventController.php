<?php

namespace App\Http\Controllers\Api;

use App\Repositories\EventRepository;
use App\Repositories\UserRepository;
use App\Models\EventFieldOrder;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\DB;

class EventController
{
    public function __construct(
        private EventRepository $eventRepository,
        private UserRepository $userRepository
    ) {}

    public function index(Request $request): JsonResponse
    {
        $token = $request->query('token');
        $page = (int) $request->query('page', 1);
        $perPage = (int) $request->query('per_page', 6);

        if (empty($token)) {
            return response()->json([], 400);
        }

        $user = $this->userRepository->findByToken($token);

        if (!$user) {
            return response()->json([], 401);
        }

        // Use paginated method
        $pagination = $this->eventRepository->findByUserPaginated($user->id_user, $page, $perPage);
        $events = $pagination['data'];

        $response = $events->map(function ($event) {
            return [
                'id' => $event->id_event,
                'slug' => $event->slug,
                'name_event' => $event->name_event,
                'date_event' => $event->date_event->format('Y-m-d'),
                'location_event' => $event->location_event,
                'guest_total' => $event->guest_total,
                'event_default_guest_pic' => $event->event_default_guest_pic,
            ];
        });

        return response()->json([
            'data' => $response->values(),
            'pagination' => [
                'total' => $pagination['total'],
                'per_page' => $pagination['per_page'],
                'current_page' => $pagination['current_page'],
                'last_page' => $pagination['last_page'],
            ]
        ]);
    }

    public function store(Request $request): JsonResponse
    {
        $token = $request->query('token') ?? $request->input('token');

        if (empty($token)) {
            return response()->json(['success' => false, 'message' => 'Token required'], 400);
        }

        $user = $this->userRepository->findByToken($token);
        if (!$user) {
            return response()->json(['success' => false, 'message' => 'Invalid token'], 401);
        }

        $request->validate([
            'name_event' => ['required', 'string', 'max:100'],
            'date_event' => ['required', 'date'],
            'location_event' => ['required', 'string', 'max:100'],
            'guest_total' => ['required', 'integer', 'min:10'],
            'event_default_guest_pic' => ['nullable', 'string', 'max:255'],
        ]);

        // Reject if slug is provided (slug is auto-generated)
        if ($request->has('slug')) {
            return response()->json([
                'success' => false,
                'message' => 'Slug tidak dapat diatur secara manual. Slug akan dibuat otomatis dari nama event.',
            ], 422);
        }

        if ($request->input('guest_total') < 10) {
            return response()->json([
                'success' => false,
                'message' => 'Minimum guest is 10 people',
            ], 400);
        }

        // Check if event name already exists for this user
        $existingEvent = $this->eventRepository->findByNameAndUser(
            $request->input('name_event'),
            $user->id_user
        );

        if ($existingEvent) {
            return response()->json([
                'success' => false,
                'message' => 'Event dengan nama yang sama sudah ada. Silakan gunakan nama yang berbeda.',
            ], 422);
        }

        // Only allow specific fields, exclude slug (will be auto-generated)
        $event = $this->eventRepository->create([
            'id_user' => $user->id_user,
            'name_event' => $request->input('name_event'),
            'date_event' => $request->input('date_event'),
            'location_event' => $request->input('location_event'),
            'guest_total' => $request->input('guest_total'),
            'event_default_guest_pic' => $request->input('event_default_guest_pic', '/event/avatar.jpg'),
            // Slug will be auto-generated by model boot method
        ]);

        return response()->json([
            'success' => true,
            'message' => 'Event Created',
            'data' => [
                'id' => $event->id_event,
                'slug' => $event->slug,
                'name' => $event->name_event,
                'date' => $event->date_event->format('Y-m-d'),
                'total' => $event->guest_total,
            ],
        ], 201);
    }

    public function show(Request $request, string $identifier): JsonResponse
    {
        $token = $request->query('token');

        if (empty($token)) {
            return response()->json([], 400);
        }

        $user = $this->userRepository->findByToken($token);
        if (!$user) {
            return response()->json([], 401);
        }

        // Support both slug and ID for backward compatibility
        $event = $this->eventRepository->findBySlugOrIdAndUser($identifier, $user->id_user);
        if (!$event) {
            return response()->json([], 404);
        }

        return response()->json([
            'id' => $event->id_event,
            'id_event' => $event->id_event,
            'slug' => $event->slug,
            'name_event' => $event->name_event,
            'date_event' => $event->date_event->format('Y-m-d'),
            'location_event' => $event->location_event,
            'guest_total' => $event->guest_total,
            'event_default_guest_pic' => $event->event_default_guest_pic,
        ]);
    }

    public function update(Request $request, string $identifier): JsonResponse
    {
        $token = $request->query('token') ?? $request->input('token');

        if (empty($token)) {
            return response()->json(['success' => false, 'message' => 'Token required'], 400);
        }

        $user = $this->userRepository->findByToken($token);
        if (!$user) {
            return response()->json(['success' => false, 'message' => 'Invalid token'], 401);
        }

        // Support both slug and ID for backward compatibility
        $event = $this->eventRepository->findBySlugOrIdAndUser($identifier, $user->id_user);
        if (!$event) {
            return response()->json(['success' => false, 'message' => 'Event not found'], 404);
        }

        $request->validate([
            'name_event' => ['sometimes', 'string', 'max:100'],
            'date_event' => ['sometimes', 'date'],
            'location_event' => ['sometimes', 'string', 'max:100'],
            'guest_total' => ['sometimes', 'integer', 'min:10'],
            'event_default_guest_pic' => ['nullable', 'string', 'max:255'],
        ]);

        // Reject if slug is provided (slug is auto-generated)
        if ($request->has('slug')) {
            return response()->json([
                'success' => false,
                'message' => 'Slug tidak dapat diatur secara manual. Slug akan dibuat otomatis dari nama event.',
            ], 422);
        }

        // Check if event name already exists for this user (excluding current event)
        if ($request->has('name_event') && $request->input('name_event') !== $event->name_event) {
            $existingEvent = $this->eventRepository->findByNameAndUser(
                $request->input('name_event'),
                $user->id_user
            );

            if ($existingEvent && $existingEvent->id_event !== $event->id_event) {
                return response()->json([
                    'success' => false,
                    'message' => 'Event dengan nama yang sama sudah ada. Silakan gunakan nama yang berbeda.',
                ], 422);
            }
        }

        // Only allow specific fields, exclude slug (will be auto-generated if name changes)
        $updateData = $request->only([
            'name_event',
            'date_event',
            'location_event',
            'guest_total',
            'event_default_guest_pic',
        ]);
        
        // Remove slug if somehow included (should not be from frontend)
        unset($updateData['slug']);
        
        $this->eventRepository->update($event, $updateData);

        return response()->json([
            'success' => true,
            'message' => 'Event Updated',
        ]);
    }

    public function destroy(Request $request, string $identifier): JsonResponse
    {
        $token = $request->query('token') ?? $request->input('token');

        if (empty($token)) {
            return response()->json(['success' => false, 'message' => 'Token required'], 400);
        }

        $user = $this->userRepository->findByToken($token);
        if (!$user) {
            return response()->json(['success' => false, 'message' => 'Invalid token'], 401);
        }

        // Support both slug and ID for backward compatibility
        $event = $this->eventRepository->findBySlugOrIdAndUser($identifier, $user->id_user);
        if (!$event) {
            return response()->json(['success' => false, 'message' => 'Event not found'], 404);
        }

        $this->eventRepository->delete($event);

        return response()->json([
            'success' => true,
            'message' => 'Event deleted',
        ]);
    }

    public function updateLogo(Request $request, string $identifier): JsonResponse
    {
        $token = $request->query('token') ?? $request->input('token');

        if (empty($token)) {
            return response()->json(['success' => false, 'message' => 'Token required'], 400);
        }

        $user = $this->userRepository->findByToken($token);
        if (!$user) {
            return response()->json(['success' => false, 'message' => 'Invalid token'], 401);
        }

        // Support both slug and ID for backward compatibility
        $event = $this->eventRepository->findBySlugOrIdAndUser($identifier, $user->id_user);
        if (!$event) {
            return response()->json(['success' => false, 'message' => 'Event not found'], 404);
        }

        $request->validate([
            'logo' => ['required', 'image', 'mimes:jpeg,jpg,png,webp', 'max:2048'], // max 2MB
        ]);

        try {
            // Delete old logo if exists (and not default)
            if ($event->event_default_guest_pic && 
                $event->event_default_guest_pic !== '/event/avatar.jpg' &&
                Storage::disk('public')->exists($event->event_default_guest_pic)) {
                Storage::disk('public')->delete($event->event_default_guest_pic);
            }

            // Store new logo
            $file = $request->file('logo');
            $path = $file->store("events/{$event->id_event}/logo", 'public');
            
            // Update event
            $event->event_default_guest_pic = $path;
            $event->save();

            return response()->json([
                'success' => true,
                'message' => 'Logo updated successfully',
                'data' => [
                    'logo_url' => Storage::disk('public')->url($path),
                    'logo_path' => $path,
                ],
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to upload logo: ' . $e->getMessage(),
            ], 500);
        }
    }

    public function getFieldOrders(Request $request, string $identifier): JsonResponse
    {
        $token = $request->query('token');

        if (empty($token)) {
            return response()->json(['success' => false, 'message' => 'Token required'], 400);
        }

        $user = $this->userRepository->findByToken($token);
        if (!$user) {
            return response()->json(['success' => false, 'message' => 'Invalid token'], 401);
        }

        // Support both slug and ID for backward compatibility
        $event = $this->eventRepository->findBySlugOrIdAndUser($identifier, $user->id_user);
        if (!$event) {
            return response()->json(['success' => false, 'message' => 'Event not found'], 404);
        }

        $formType = $request->query('form_type', 'add');

        $fieldOrders = EventFieldOrder::where('id_event', $event->id_event)
            ->where('form_type', $formType)
            ->orderBy('field_order')
            ->get()
            ->map(function ($order) {
                return [
                    'id_order' => $order->id_order,
                    'field_type' => $order->field_type,
                    'field_key' => $order->field_key,
                    'field_order' => $order->field_order,
                    'is_visible' => $order->is_visible,
                ];
            });

        return response()->json([
            'success' => true,
            'data' => $fieldOrders,
        ]);
    }

    public function updateFieldOrders(Request $request, string $identifier): JsonResponse
    {
        $token = $request->query('token') ?? $request->input('token');

        if (empty($token)) {
            return response()->json(['success' => false, 'message' => 'Token required'], 400);
        }

        $user = $this->userRepository->findByToken($token);
        if (!$user) {
            return response()->json(['success' => false, 'message' => 'Invalid token'], 401);
        }

        // Support both slug and ID for backward compatibility
        $event = $this->eventRepository->findBySlugOrIdAndUser($identifier, $user->id_user);
        if (!$event) {
            return response()->json(['success' => false, 'message' => 'Event not found'], 404);
        }

        $request->validate([
            'form_type' => ['required', 'string', 'in:add,edit,complete_profile'],
            'field_orders' => ['required', 'array'],
            'field_orders.*.field_type' => ['required', 'string', 'in:default,custom'],
            'field_orders.*.field_key' => ['required', 'string'],
            'field_orders.*.field_order' => ['required', 'integer', 'min:0'],
            'field_orders.*.is_visible' => ['sometimes', 'boolean'],
        ]);

        try {
            DB::transaction(function () use ($event, $request) {
                $formType = $request->input('form_type');
                
                // Delete existing orders for this form type
                EventFieldOrder::where('id_event', $event->id_event)
                    ->where('form_type', $formType)
                    ->delete();

                // Insert new orders
                foreach ($request->input('field_orders') as $order) {
                    EventFieldOrder::create([
                        'id_event' => $event->id_event,
                        'form_type' => $formType,
                        'field_type' => $order['field_type'],
                        'field_key' => $order['field_key'],
                        'field_order' => $order['field_order'],
                        'is_visible' => $order['is_visible'] ?? true,
                    ]);
                }
            });

            return response()->json([
                'success' => true,
                'message' => 'Field orders updated successfully',
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to update field orders: ' . $e->getMessage(),
            ], 500);
        }
    }
}
